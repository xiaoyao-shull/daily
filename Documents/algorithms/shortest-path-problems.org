#+OPTIONS: toc:1
#+TITLE: Shortest Path Problems

* Single Source Shortest Path Problems in Directed Acyclic Networks
  + A topological ordering of nodes is available for a directed acyclic network such that for any $(i, j) \in A$, $i$ appears before $j$ in the ordering.
  + Two similar algorithms based on this topological ordering can be established.
  + The complexity is $O(m)$ for both algorithms, since each arc is examined exactly once in each execution.
  + The reaching algorithm is prefered since we usually maintain the adjacent-list $A(i)$ for node $i \in N$.

** The Pulling Algorithm
   #+BEGIN_VERSE
     *algorithm* Pulling;
     *begin*
         $d(s) \leftarrow 0, \mbox{pred}(s) \leftarrow 0$;
         $d(i) \leftarrow \infty$ for all $i \in N - \{ s \}$;
         *for* each node $j \in N$ in topological ordering *do*
             *for* all arc $(i, j), i \in N$ *do*
                 *if* $d(j) > d(i) + c_{ij}$ *then*
                 *begin*
                     $d(j) \leftarrow d(i) + c_{ij}$;
                     $\mbox{pred}(i) \leftarrow j$;
                 *end*;
     *end*;
   #+END_VERSE

** The Reaching Algorithm
   #+BEGIN_VERSE
     *algorithm* Reaching;
     *begin*
         $d(s) \leftarrow 0, \mbox{pred}(s) \leftarrow 0$;
         $d(i) \leftarrow \infty$ for all $i \in N - \{ s \}$;
         *for* each node $i \in N$ in topological ordering *do*
             *for* all arc $(i, j), j \in N$ *do*
                 *if* $d(j) > d(i) + c_{ij}$ *then*
                 *begin*
                     $d(j) \leftarrow d(i) + c_{ij}$;
                     $\mbox{pred}(i) \leftarrow j$;
                 *end*;
     *end*;
   #+END_VERSE

* Single Source Shortest Path Problems in Networks With No Negative Arc Length

** Dijkstra Algorithm
   #+BEGIN_VERSE
     *algorithm* Dijkstra's;
     *begin*
         $S \leftarrow \emptyset, \bar S \leftarrow N$;
         $d(s) \leftarrow 0, \mbox{pred}(s) \leftarrow 0$;
         $d(s) \leftarrow \infty$ for all $i \in N - \{ s \}$;
         *while* $|S| < n$ *do*
         *begin*
             let $i \in \bar S$ be some node such that $d(i) = \mbox{min} \{ d(j) : j \in \bar S \}$;
             $S \leftarrow S \cup \{ i \}$;
             $\bar S \leftarrow \bar S - \{ i \}$;
             *for* each $(i, j) \in A(i)$ *do*
                 *if* $d(j) > d(i) > c_{ij}$ *then*
                 *begin*
                     $d(j) \leftarrow d(i) + c_{ij}$;
                     $\mbox{pred}(j) \leftarrow i$;
                 *end*;
         *end*;
     *end*;
   #+END_VERSE
   + The node selecting operations cost $O(n^2)$.
   + The distance updating operations cost $O(m)$.
   + Since the upper bound of $m$ is $O(n^2)$, Dijkstra's algorithm runs in $O(n^2)$.

** Optimization: Bidiretional Search
   + We perform two instances of Dijkstra's algorithm in parallel.
   + The forward one is as usual, we assign distance label $d(i)$ to node $i \in N$, and mutually divide nodes into $S$ and $\bar S$.
   + The backward one treats the sink node $t$ as the source node, and an arc $(i, j) \in A$ as an arc $(j, i)$.
   + The backward Dijkstra's algorithm assign distance label $d'(i)$ to node $i \in N$, and mutually divide nodes into $S'$ and $\bar{S'}$.
   + How we altering between forward and backward Dijkstra's algorithms does not matter.
   + The algorithm terminates when there exists a node $k$ such that $k \in S \cap S'$.
   + Note that the node $k$ is not necessarily in a shortest path.
   + In fact the shortest path is $\min \{ d(i) + d'(i): i \in S \cup S' \}$.
   + As a proof, consider some shortest path $P$, whose length is $L$, from $s$ to $t$ that does not pass the node $k$.
   + Suppose that nodes $p$ and $q$ are respectively the first and the last node not in $S \cup S'$ along path $P$.
   + $d(p)$ is optimal at the moment, since $p$ can be reached by some node in $S$.
   + Likewise, $d'(q)$ is also optimal.
   + $p \not \in S$ and $k \in S \implies d(k) \le d(p)$, otherwise we won't choose $k$ from $\bar S$ before choosing $p$.
   + Likewise, $q \not \in S'$ and $k \in S' \implies d'(k) \le d'(q)$.
   + Now we can enumerate over the existence of $p$ and $q$:
     - If $p$ and $q$ are different nodes, then $d(k) + d'(k) \le d(p) + d'(q) < L$, which is impossible.
     - If $p$ and $q$ are the same node, then $L \le d(k) + d'(k) \le d(p) + d'(q) = L$, which implies $d(k) + d'(k) = L$.
     - If $p$ and $q$ do not exist, then $i \in S \cup S'$ for all $i \in P$, and $d(i) + d'(i) = L$.


** Optimization: Heap
   + We concern ourselves with the following operations of the heap data structure:
     - $\mbox{create-heap}(H)$
     - $\mbox{find-min}(H)$
     - $\mbox{insert}(H, i)$
     - $\mbox{decrease-key}(H, i, \Delta)$
     - $\mbox{delete-min}(H)$
   + For convenience, we represent the decrease-key operation as $\mbox{decrease-key}(H, i, i')$ where $i'$ is the updated value of $i$.
   #+BEGIN_VERSE
     *algorithm* Heap Dijkstra's;
     *begin*
         $d(s) \leftarrow 0, \mbox{pred}(s) \leftarrow 0$;
         $d(s) \leftarrow \infty$ for all $i \in N - \{ s \}$;
         $\mbox{create-heap}(H)$;
         $\mbox{insert}(H, s)$;
         *while* $H \neq \emptyset$ *do*
         *begin*
             $i \leftarrow \mbox{find-min}(H)$;
             $\mbox{delete-min}(H)$;
             *for* each $(i, j) \in A(i)$ *do*
                 *if* $d(j) > d(i) + c_{ij}$ *then*
                     *if* $d(j) = \infty$ *then*
                     *begin*
                         $d(j) \leftarrow d(i) + c_{ij}$;
                         $\mbox{pred}(j) \leftarrow i$;
                         $\mbox{insert}(H, j)$;
                     *end*
                     *else*
                     *begin*
                         $d(j) \leftarrow d(i) + c_{ij}$;
                         $\mbox{pred}(j) \leftarrow i$;
                         $\mbox{decrease-key}(H, j, d(i) + c_{ij})$;
                     *end*;
         *end*;
     *end*;
   #+END_VERSE
   + Different heap implementation gives different complexity:
     |                       | Binary Heap        | Fibonacci Heap     |
     |-----------------------+--------------------+--------------------|
     | $\mbox{create-heap}$  | $\Theta(1)$        | $\Theta(1)$        |
     | $\mbox{find-min}$     | $\Theta(n)$        | $O(n)$ (amortized) |
     | $\mbox{insert}$       | $O(\log n)$        | $\Theta(1)$        |
     | $\mbox{decrease-key}$ | $O(\log n)$        | $\Theta(1)$        |
     | $\mbox{delete-min}$   | $\Theta(\log n)$   | $\Theta(1)$        |
     |-----------------------+--------------------+--------------------|
     | Dijkstra's Complexity | $O((m + n)\log n)$ | $O(m + n\log n)$   |

** Optimization: Dial's Implementation
   + Dial's implementation avoids node selecting operations by using $(1 + nC)$ buckets to hold nodes when their distance labels are finite but not confirmed as optimal.
   + Each bucket corresponds to a unique distance from the source node along some directed path.
   + Nodes in each bucket are kept in doubly linked list, making adding/removing a node cost only $O(1)$.
   + The number of buckets can be reduced to $(1 + C)$, since whenever we update $d(j)$ with $d(i) + c_{ij}$, the updated value falls in $[d(i), d(i) + C]$.
   + The complexity of this implementation is $O(m + nC)$.

* Single Source Shortest Path Problems in Networks With Arbitrary Arc Lengths

** TODO Optimality Condition
** TODO Generic Label-Correcting Algorithm
** TODO Modified Label-Correcting Algorithm
** TODO Detecting Negative Cycles

* All-Pair Shortest Path Problems in Networks With Arbitrary Arc Lengths

** TODO Repeated Shortest Path Algorithm
** TODO Generic Label-Correcting Algorithm
** TODO Floyd-Warshall Algorithm
** TODO Detecting Negative Cycles
