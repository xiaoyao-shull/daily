#+OPTIONS: toc:1
#+TITLE: Shortest Path Problems

* Single Source Shortest Path Problems in Directed Acyclic Networks
  + A topological ordering of nodes is available for a directed acyclic network such that for any $(i, j) \in A$, $i$ appears before $j$ in the ordering.
  + Two similar algorithms based on this topological ordering can be established.
  + The complexity is $O(m)$ for both algorithms, since each arc is examined exactly once in each execution.
  + The reaching algorithm is prefered since we usually maintain the adjacent-list $A(i)$ for node $i \in N$.

** The Pulling Algorithm
   #+BEGIN_VERSE
     *algorithm* Pulling;
     *begin*
         $d(s) \leftarrow 0, \mbox{pred}(s) \leftarrow 0$;
         $d(i) \leftarrow \infty$ for all $i \in N - \{ s \}$;
         *for* each node $j \in N$ in topological ordering *do*
             *for* all arc $(i, j), i \in N$ *do*
                 *if* $d(j) > d(i) + c_{ij}$ *then*
                 *begin*
                     $d(j) \leftarrow d(i) + c_{ij}$;
                     $\mbox{pred}(i) \leftarrow j$;
                 *end*;
     *end*;
   #+END_VERSE

** The Reaching Algorithm
   #+BEGIN_VERSE
     *algorithm* Reaching;
     *begin*
         $d(s) \leftarrow 0, \mbox{pred}(s) \leftarrow 0$;
         $d(i) \leftarrow \infty$ for all $i \in N - \{ s \}$;
         *for* each node $i \in N$ in topological ordering *do*
             *for* all arc $(i, j), j \in N$ *do*
                 *if* $d(j) > d(i) + c_{ij}$ *then*
                 *begin*
                     $d(j) \leftarrow d(i) + c_{ij}$;
                     $\mbox{pred}(i) \leftarrow j$;
                 *end*;
     *end*;
   #+END_VERSE

* Single Source Shortest Path Problems in Networks With No Negative Arc Length

** Dijkstra Algorithm
   #+BEGIN_VERSE
     *algorithm* Dijkstra's;
     *begin*
         $S \leftarrow \emptyset, \bar S \leftarrow N$;
         $d(s) \leftarrow 0, \mbox{pred}(s) \leftarrow 0$;
         *d(s) \leftarrow \infty* for all $i \in N - \{ s \}$;
         *while* $|S| < n$ *do*
         *begin*
             let $i \in \bar S$ be some node such that $d(i) = \mbox{min} \{ d(j) : j \in \bar S \}$;
             $S \leftarrow S \cup \{ i \}$;
             $\bar S \leftarrow \bar S - \{ i \}$;
             *for* each $(i, j) \in A(i)$ *do*
                 *if* $d(j) > d(i) > c_{ij}$ *then*
                 *begin*
                     $d(j) \leftarrow d(i) + c_{ij}$;
                     $\mbox{pred}(j) \leftarrow i$;
                 *end*;
         *end*;
     *end*;
   #+END_VERSE
   + The node selecting operations cost $O(n^2)$.
   + The distance updating operations cost $O(m)$.
   + Since the upper bound of $m$ is $O(n^2)$, Dijkstra's algorithm runs in $O(n^2)$.

** Optimization: Bidiretional Search
   + We perform two instances of Dijkstra's algorithm in parallel.
   + The forward one is as usual, we assign distance label $d(i)$ to node $i \in N$, and mutually divide nodes into $S$ and $\bar S$.
   + The backward one treats the sink node $t$ as the source node, and an arc $(i, j) \in A$ as an arc $(j, i)$.
   + The backward Dijkstra's algorithm assign distance label $d'(i)$ to node $i \in N$, and mutually divide nodes into $S'$ and $\bar{S'}$.
   + How we altering between forward and backward Dijkstra's algorithms does not matter.
   + The algorithm terminates when there exists a node $k$ such that $k \in S \cap S'$.
   + Note that the node $k$ is not necessarily in a shortest path.
   + In fact the shortest path is $\min \{ d(i) + d'(i): i \in S \cup S' \}$.
   + As a proof, consider some shortest path $P$, whose length is $L$, from $s$ to $t$ that does not pass the node $k$.
   + Suppose node $p$ is the first node not in $S$ along path $P$ and $q$ the last node not in $S'$.
   + $d(p)$ and $d'(q)$ are optimal at this moment since they can be reached by nodes along some shortest path in $S$ and $S'$ respectively.
   + $p \not \in S$ and $k \in S$ implies that $d(k) \le d(p)$, otherwise we won't choose $k$ from $\bar S$ before choosing $p$.
   + Likewise, $q \not \in S'$ and $k \in S'$ implies that $d'(k) \le d'(q)$.
   + We can enumerate over the existence of $p$ and $q$:
     - If $p$ and $q$ are different nodes, then $d(k) + d'(k) \le d(p) + d'(q) < L$, which is impossible.
     - If $p$ and $q$ are the same node, then $d(k) + d'(k) \le d(p) + d'(q) = L$, while $d(k) + d'(k) \ge L$, we have $d(k) + d'(k) = L$.
     - If both $p$ and $q$ do not exist, then $i \in S \cup S'$ for all $i \in P$.
   + In any of the situations list above, the shortest path length can be determined by $\min \{ d(i) + d'(i): i \in S \cup S' \}$.

** TODO Optimization: Heap
** TODO Optimization: Dial's Implementation

* Single Source Shortest Path Problems in Networks With Arbitrary Arc Lengths

** TODO Optimality Condition
** TODO Generic Label-Correcting Algorithm
** TODO Modified Label-Correcting Algorithm
** TODO Detecting Negative Cycles

* All-Pair Shortest Path Problems in Networks With Arbitrary Arc Lengths

** TODO Repeated Shortest Path Algorithm
** TODO Generic Label-Correcting Algorithm
** TODO Floyd-Warshall Algorithm
** TODO Detecting Negative Cycles
